---------------------------------------------------------------------------------------------------

TCP/IP协议族四层模型

应用层：
	作用：为应用程序提供网络服务接口。它包含了所有高层协议，用于支持网络应用之间的通信，比如文件传输、电子邮件、远程登录等。
	主要协议：HTTP，FTP，SMTP，DNS等

传输层：
	作用：提供进程到进程的通信服务，确保数据可靠地传输。该层负责错误检测与纠正，以及流量控制。
	主要协议：TCP，UDP。其中，TCP提供可靠的、面向连接的服务；UDP则提供不可靠的、无连接的服务。
	TCP, UDP数据段包含了进程的端口号，负责找到进程

网络层：
	作用：提供主机到主机的通信服务，不保证可靠性。负责选择数据包的传输路径，即路由选择。
	主要协议：IP，ICMP，IGMP，ARP等
	IP数据段包含了主机的IP地址，负责找到主机

链路层(网络接口层)：
	作用：负责在物理网络上发送和接收IP数据包。它定义了如何使用底层的物理传输媒介(如电缆或无线)进行数据帧的传输。
	主要协议：以太网、Wi-Fi等

---------------------------------------------------------------------------------------------------

应用层协议


HTTP(HyperText Transfer Protocol，超文本传输协议)：
HTTP是一个用于传输网页数据的协议，使得用户可以通过点击链接来浏览文本、图像以及其他类型的文件。
它定义了浏览器和服务器之间的数据传输格式。如请求格式，相应格式


HTTPS(HyperText Transfer Protocol Secure，超文本传输安全协议):
HTTP协议的安全版本，其核心在于它使用SSL(Secure Sockets Layer)或其后续技术TLS(Transport Layer Security)来加密通信


HTML(HyperText Markup Language，超文本标记语言):
制作网页使用的标准语言


XML(Extensible Markup Language，可扩展标记语言):
一种类似于HTML的标记语言，用来传输和存储数据，而不是显示数据(HTML是为了显示数据)


DNS(Domain Name System，域名系统)：
DNS是互联网的一项核心服务，将域名(例如www.baidu.com)转换成IP地址

---------------------------------------------------------------------------------------------------

运输层协议


TCP(Transmission Control Protocol，传输控制协议)
	1.有连接：TCP提供了一种可靠的、有连接的服务。在数据传输之前，客户端和服务器之间需要建立一个连接(三次握手)，以确保双方都准备好进行通信。
	2.可靠性：TCP通过序列号、确认应答、重传机制等手段确保数据能够可靠地从发送方传递到接收方。如果数据包丢失或损坏，TCP会自动重发这些数据包。
	3.有序性：即使数据包到达的顺序混乱，TCP也能将它们按照正确的顺序重新组装后交给应用程序。
	4.流量控制和拥塞控制：TCP具有内置的机制来避免网络过载，并且可以根据网络状况动态调整数据传输速率。
	5.应用场景：由于其高可靠性的特点，TCP常用于对数据准确性要求较高的应用，如文件传输(FTP)、电子邮件(SMTP)、网页浏览(HTTP/HTTPS)等。
	
TCP传输字节流



UDP(User Datagram Protocol，用户数据报协议)
	1.无连接：与TCP不同，UDP是一种无连接的协议，这意味着它不建立连接就可以直接发送数据报文。这种方式减少了延迟，适合于实时性要求高的应用。
	2.不可靠但高效：UDP不保证数据包一定能成功送达目的地，也不负责数据包的排序和重传。因此，UDP的数据传输效率更高，开销更小。
	3.低延迟：因为没有建立连接的过程，也没有复杂的错误检查和纠正机制，所以UDP能够提供更低的延迟，非常适合于时间敏感的应用，如语音通话、视频会议、在线游戏等。
	4.应用场景：UDP适用于那些即使丢失少量数据包也不会严重影响用户体验的情况，比如多媒体流媒体播放、DNS查询、VoIP电话等。
	
UDP传输报文

---------------------------------------------------------------------------------------------------

网络层协议


IP协议(Internet Protocol，网际协议)
负责在网络中将数据包从一个节点传输到另一个节点。定义了数据应如何被格式化、寻址、路由以及分割成适合传输的小块，并在目的地重新组装。


ARP(Address Resolution Protocol，地址解析协议)
主要用于解决同一个局域网内IP地址到MAC地址的映射问题。

---------------------------------------------------------------------------------------------------

C/S模式(Client/Server，客户端/服务器模式)

	客户端负责提供用户界面，并处理用户的输入；而服务端则负责处理业务逻辑、数据存储及管理等后台任务。
	客户端通过网络向服务端发送请求，服务端处理这些请求后将结果返回给客户端。

特点：
	需要安装特定软件
	由于需要安装特定软件，因此安全性较差
	更新时需要同时更新客户端和服务端，开发成本较高。而且需要用户手动更新客户端软件
	跨平台兼容性差
	可以缓存大量数据
	可以使用自定义协议



B/S模式(Browser/Server，浏览器/服务器模式)

	B/S模式是一种特殊的C/S模式，其中客户端使用通用的Web浏览器代替专门开发的软件。
	所有用户界面都通过网页的形式呈现，所有的业务逻辑都在服务器端实现。这意味着用户只需拥有一个支持HTML的浏览器即可访问系统。

特点：
	无需额外软件，只需浏览器，降低了开发成本
	由于没有额外软件，因此安全性较好
	维护简便，只需更新服务器端代码
	跨平台兼容性好
	受限于浏览器的功能限制，某些高级功能实现起来较为复杂。
	不能缓存大量数据
	必须严格遵守HTTP协议

---------------------------------------------------------------------------------------------------

套接字(Socket)


套接字是一种用于网络通信的编程接口，它使得不同计算机上的应用程序能够通过网络进行数据交换。
本质上是基于TCP/IP协议族的网络系统调用接口

通信过程中，套接字成对使用，发送方接收方各有一个套接字

Linux中，调用系统函数创建一个套接字后，返回一个文件描述符指向该套接字。该套接字内部有两个内核提供的缓冲区实现读写

---------------------------------------------------------------------------------------------------

最低有效字节(Least Significant Byte, LSB)

最低有效字节指的是一个数值中权重最小、对数值大小影响最小的那个字节。即位于最右边的字节，对于数值的整体值贡献最小。
例如，在一个16位的整数0x1234中，0x34是最低有效字节


最高有效字节(Most Significant Byte, MSB)

最高有效字节指的是一个数值中权重最大、对数值大小影响最大的那个字节。即位于最左边的字节，对于数值的整体值贡献最大。
例如，在一个16位的整数0x1234中，0x12是最高有效字节

---------------------------------------------------------------------------------------------------

字节序(Endianness)

字节序指的是多字节数据类型(如整数、浮点数等)在计算机内存中存储时，其字节的排列顺序。
它决定了数据的最低有效字节和最高有效字节如何在内存地址中排列
字节序主要分为两大类：大端序(Big-endian)和小端序(Little-endian)

!!! TCP/IP协议栈默认使用大端序，计算机一般使用小端序。所以在进行网络通信时要转换字节序


大端序(Big-endian)
在大端序中，最高有效字节存储在内存中的最低地址处，而最低有效字节则存储在最高地址处。
这种排序方式与人类阅读数字的习惯一致，即从左到右的重要性递减。
例如，一个16位的整数值0x1234在内存中的表示如下(假设起始地址为0x0020)：
		地址    0x0020  0x0021
		数据    0x12    0x34


小端序(Little-endian)
在小端序中，情况正好相反，最低有效字节存储在内存的最低地址处，而最高有效字节存储在最高地址处。
同样的16位整数值0x1234在小端序下的内存表示如下(假设起始地址为0x0020)：
		地址    0x0020  0x0021
		数据    0x34    0x12



在C语言中，可以使用以下函数进行主机字节序与网络字节序之间的转换:

htons()：将16位(端口)的主机字节序转换为网络字节序（Host TO Network Short）
htonl()：将32位(IP)  的主机字节序转换为网络字节序（Host TO Network Long）
ntohs()：将16位(端口)的网络字节序转换为主机字节序（Network TO Host Short）
ntohl()：将32位(IP)  的网络字节序转换为主机字节序（Network TO Host Long）

在进行IP(例如"192.168.1.1"这是一个字符串类型)转换时，由于这几个函数操作的数据都是整型，因此需要额外的字符串类型转换。
这导致需要两步才能完成转换，所以进行IP转换时一般用下面的两个系统函数

而端口本身可以作为整型输入，所以没有必要进行两步转换，直接使用htons()或ntohs()即可



inet_pton(): 将人类可读的IP地址字符串转换为网络字节序二进制形式(系统函数)

int inet_pton(int af, const char *src, void *dst);
	af: 指定地址族，可以是 AF_INET（IPv4）或 AF_INET6（IPv6）
	src: 指向IP地址字符串的指针。IPv4地址格式为点分十进制（192.168.1.1）。IPv6地址格式为冒号分隔的十六进制数（2001:db8::1）
	dst: 指向一个缓冲区的指针，该缓冲区用来存放转换后的二进制IP地址。对于IPv4地址，缓冲区至少需要4个字节的空间；对于IPv6地址，至少需要16个字节。

返回值
	成功时，返回值为 1。
	如果输入的字符串不是一个有效的IP地址表达形式，则返回 0。
	如果遇到更严重的错误（比如不支持的地址族），则返回 -1 并设置 errno。
	
	
	
inet_ntop(): 将网络地址从二进制转换为人类可读的字符串表示形式(系统函数)

const char* inet_ntop(int af, const void *src, char *dst, socklen_t size);
	af: 指定地址族，可以是 AF_INET（IPv4）或 AF_INET6（IPv6）
	src: 指向包含网络地址二进制数据的指针
	dst: 目标缓冲区的指针，用于存储转换后的IP地址字符串。该缓冲区应足够大以容纳输出字符串（包括结尾的空字符）。
		 对于IPv4地址，至少需要INET_ADDRSTRLEN字节的空间；对于IPv6地址，则至少需要INET6_ADDRSTRLEN字节。
	size: 目标缓冲区的大小（单位为字节）

返回值
	成功时，返回指向目标缓冲区 dst 的指针，其中包含了转换后的IP地址字符串。
	错误则返回 NULL 并设置 errno 来指示错误类型。

---------------------------------------------------------------------------------------------------