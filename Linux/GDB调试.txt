编译时添加 -g 选项来生成调试信息
gcc -g program.c -o program

---------------------------------------------------------------------------------------------------

执行gdb ./program
或者执行gdb启动gdb，然后执行file ./program加载程序

---------------------------------------------------------------------------------------------------

运行程序:
run		缩写r

---------------------------------------------------------------------------------------------------

设置main函数参数：
set args 参数1,参数2,参数3...	注：在程序运行前设置
run 参数1,参数2,参数3...		注：在run命令中设置参数


带参的标准main函数：int main(int argc, char* argv[])
argc(argument count)：表示命令行参数的数量（包括程序名本身）。至少为 1，因为第一个参数始终是程序的名称
argv(argument vector)：一个字符指针数组，存储了命令行参数的字符串
argv[0] 是程序的名称或路径
argv[1] 到 argv[argc-1] 是用户传递的实际参数

---------------------------------------------------------------------------------------------------

查看源码：
list	缩写l	列出10行代码
继续使用list会列出接下来的10行代码

---------------------------------------------------------------------------------------------------

设置断点：
break 10	在第10行设置断点		缩写b
break main	在main函数处设置断点	缩写b


设置条件断点：
b [文件名:]行号 if 条件
例如，在第5行设置一个断点，当a == 10时触发：
b 5 if a == 10
例如，在hello.cpp文件的第5行设置一个断点，当a == 10时触发：
b hello.cpp:5 if a == 10


查看断点：
info breakpoints	缩写info b


删除断点：
delete 断点编号
断点编号不是行号

---------------------------------------------------------------------------------------------------

单步执行：
next	缩写n	不进入函数内部
step	缩写s	进入函数内部


继续执行：
contitues	缩写c	运行直到下一个断点


结束当前函数调用：
finish


如果有fork()创建子进程，在fork()执行之前
set follow-fork-mode parent 跟踪父进程(默认)
set follow-fork-mode child 跟踪子进程

---------------------------------------------------------------------------------------------------

查看变量：
print 变量名	缩写p 变量名
只能查看所处上下文变量


查看变量类型：
ptype 变量名


持续追踪变量：
display 变量名


解除持续追踪变量：
undisplay 持续追踪变量编号

---------------------------------------------------------------------------------------------------

查看当前函数调用堆栈：
backtrace	缩写bt


切换函数堆栈：
frame 堆栈编号

---------------------------------------------------------------------------------------------------

退出GDB：
quit	缩写q