运行makefile脚本需要make工具
执行apt install make来安装make工具(Debian)



变量

变量名=值

---------------------------------------------------------------------------------------------------

1. 规则

规则定义了目标(target)、依赖(prerequisites)和命令(commands)。其格式如下：
target: prerequisites
    commands
	
target：通常是一个输出文件的名字，如可执行文件或目标文件。也可以是一个动作名称（如 clean）
prerequisites：目标所依赖的文件列表。如果这些文件中有任何一个比目标更“新”，则需要重新生成目标
			   如果找不到依赖文件，则会寻找其他规则生成缺失的依赖文件		
commands：一组 shell 命令，用于创建或更新目标。必须以 Tab 键开头

示例：
main.o: main.c mylib.h
    gcc -c main.c -o main.o
这个规则表示，如果 main.c 或 mylib.h 文件比 main.o 新，就需要重新生成 main.o

默认情况下，makefile脚本把第一个目标当做最终目标
指定最终目标用 ALL:目标名 放在靠上的位置



clean目标

clean 通常用于清理项目中的编译产物和其他临时文件
示例：
clean:
	-rm -rf $(obj) a.out
解释:
当在命令行中运行 make clean 时，Make 将执行这个目标来删除obj所指的文件以及a.out文件
-rm中"-"的作用：忽略命令执行中的错误

---------------------------------------------------------------------------------------------------

2. 函数

wildcard

wildcard 函数用于查找与给定模式匹配的所有文件，并返回一个空格分隔的列表
示例：
	src = $(wildcard *.c)
这个命令会查找当前目录下所有以 .c 结尾的文件，并将它们作为一个空格分隔的列表赋值给变量 src
假设当前目录下有 add.c, sub.c，则 src 的值为：add.c sub.c



patsubst	(pattern substitution)

patsubst 函数用于根据给定的模式进行字符串替换

语法：$(patsubst pattern,replacement,string)
	pattern：要匹配的模式
	replacement：匹配的模式要替换的内容
	string：要进行匹配和替换的字符串
	
示例：
	obj = $(patsubst %.c,%.o,$(src))
	
这个命令会遍历 src 变量中的每个文件名，将 .c 后缀替换为 .o，并生成一个新的空格分隔的列表赋值给变量 obj
假设 src 的值为 add.c sub.c mul.cpp，则 obj 的值为：add.o sub.o mul.cpp


注：*用于文件名匹配，%用于模式匹配，不能互换

---------------------------------------------------------------------------------------------------

3. 自动变量

$@
含义：表示当前规则的目标文件名
示例：
add.o: add.cpp
	gcc add.cpp -o $@
在这个例子中，$@ 将被替换为 add.o 即目标文件名


$<
含义：表示当前规则的第一个依赖文件
示例：
add.o: add.cpp
	gcc $< -o $@
在这个例子中，$< 将被替换为 add.cpp，即第一个依赖文件


$^
含义：表示当前规则的所有依赖文件，以空格分隔
示例：
test.out: main.cpp add.cpp header.h
	gcc $^ -o $@
在这个例子中，$^ 将被替换为 main.cpp add.cpp header.h，即所有依赖文件。注意，重复的依赖文件会被去重。

---------------------------------------------------------------------------------------------------

技巧：

最终目标需要的依赖文件可以这样生成：
%.o : %.cpp
	g++ -c $< -o $@
使用模式匹配，需要哪个依赖文件生成哪个依赖文件



静态模式匹配

如果有两个规则都可以生成同名依赖文件，会产生混乱
%.o : %.cpp
	g++ -c $< -o $@

%.o : %.c
	g++ -c $< -o $@
	
使用静态模式匹配解决：
$(obj) : %.o : %.cpp
	g++ -c $< -o $@
表示obj里面的依赖文件使用这个规则生成

---------------------------------------------------------------------------------------------------

伪目标

示例问题：
想要执行这条clean规则
clean:
	rm -f *.o program
如果当前目录下恰好有一个名为 clean 的文件，Make 会认为目标已经是最新的，不会执行 rm 命令
通过将 clean 声明为伪目标，可以避免这种情况

声明伪目标，语法如下：
.PHONY: target1 target2 ...

上面clean的例子可以通过下面的方式解决：
.PHONY: clean
clean:
	rm -f *.o program

伪目标不代表任何实际文件，因此它的规则总是会被执行