---------------------------------------------------------------------------------------------------

父子进程相同点: 代码段，文件描述符，环境变量，用户ID和组ID，信号
注意：对于某些特定的信号(如SIGCHLD)，子进程通常不会自动继承父进程的处理方式。

父子进程不同点：PID和PPID，内存空间，资源占用，执行流，未决信号集，文件锁，定时器和闹钟

---------------------------------------------------------------------------------------------------

进程相关函数

fork()
getpid(), getppid()
exit()
wait(), waitpid()
kill(pid,SIGKILL)

---------------------------------------------------------------------------------------------------

创建守护进程

调用 fork() 创建子进程，然后退出父进程：
让子进程不再与任何终端相关联。

在子进程中调用 setsid() 创建新会话：
setsid() 函数创建一个新的会话，并使得该进程成为新会话的领导者，同时创建一个新的进程组和新的控制终端。

再次 fork() 一次(可选但推荐)：
确保进程不是会话首进程，因为会话首进程仍然可以获取控制终端。通过第二次 fork()并让父进程退出，子进程将不再是会话首进程。

改变当前工作目录到根目录：
使用 chdir("/") 防止守护进程占用可卸载的文件系统，避免由于守护进程的工作目录被删除或不可访问而导致的问题。

根据需要，使用umask()重新设置文件权限掩码，重置新文件创建权限

关闭标准输入、输出和错误描述符，防止守护进程从旧的控制终端读取数据或将数据写入其中。

关闭不需要的文件描述符，以免影响系统的文件描述符资源。

---------------------------------------------------------------------------------------------------

执行进程和执行线程的区别

进程
	fork()创建一个进程后，父子进程从同一个位置执行代码。可以判断pid是否为0来区分父子进程，从而在父子进程中执行不同的代码段
	
线程
	pthread_create()创建一个线程后，子线程开始执行pthread_create()第三个参数指定的函数，
	主线程继续执行pthread_create()之后的代码

---------------------------------------------------------------------------------------------------

进程和线程的关系: 一个进程可以包含多个线程

1.进程是资源分配的基本单位
	每个进程都有自己的独立内存空间(代码段、堆栈、堆、数据段等)
	它拥有系统资源(如文件描述符、信号量、虚拟地址空间等)
2.线程是调度执行的基本单位
	线程是进程中的一条执行路径。
	同一进程中的多个线程共享该进程的资源(尤其是内存空间)，但每个线程有自己的：
		栈(stack)
		寄存器上下文
		程序计数器(PC)


   特性		     进程					线程
资源拥有者	      是					 否
内存空间	     独立				 共享进程内存
创建开销	 大(复制资源)			 小(共享资源)
通信方式	IPC(管道、消息队列等)	直接访问共享变量
切换成本	      高					 低
所属关系	一个进程可以有多个线程	一个线程必须属于某个进程

---------------------------------------------------------------------------------------------------

同一进程中，线程之间共享与不共享的资源

共享资源
	1.内存空间：所有线程共享进程的地址空间，这意味着一个线程可以访问另一个线程的数据。这包括全局变量、静态变量和堆上分配的内存等。
	2.文件描述符：打开的文件、网络套接字和其他I/O资源通常是在线程间共享的，任何线程都可以读写相同的文件或socket。
	3.代码段：程序的实际可执行代码对所有线程都是可见的，因此所有线程都运行同一份代码（除非使用了动态加载技术）。
	4.数据段：包含全局变量和静态变量的数据段也是共享的。
	5.信号处理器：进程中的信号处理函数默认情况下是被所有线程共享的，不过可以为特定线程设置不同的信号掩码来控制哪些信号应该被忽略。
	6.环境变量：环境变量也是一次性设置后可供所有线程访问。

非共享资源
	1.栈空间：每个线程都有自己独立的栈空间，用于存储局部变量、函数调用信息等。
	这是为了保证线程间的隔离性和安全性，避免一个线程的操作影响到其他线程
	2.寄存器状态：每个线程在CPU上的执行上下文（如通用寄存器、指令指针、条件码等）都是独立的，确保了线程切换时的状态保存与恢复不会相互干扰。
	3.线程本地存储(Thread Local Storage,TLS)：
	这是一种机制，允许给每个线程分配其私有的数据区域，这些数据对于该线程来说是唯一的，并且不能被其他线程直接访问。
	4.信号掩码：虽然信号处理器本身是共享的，但是每个线程可以有自己的信号掩码，决定哪些信号应当被屏蔽掉而不传递给该线程。

---------------------------------------------------------------------------------------------------

线程相关函数

pthread_create(): 创建一个新的线程，允许用户指定新线程执行的函数以及传递给该函数的参数

int pthread_create(pthread_t *thread,
				   const pthread_attr_t *attr,
				   void *(*start_routine) (void *),
				   void *arg);
thread: 存储新创建线程的ID
attr: 用于设置线程的属性，如堆栈大小等。如果为 NULL，则使用默认属性。
start_routine: 新线程开始执行的函数的起始地址。此函数接受一个 void* 类型的参数并返回一个 void* 类型的结果。
arg: 传递给 start_routine 函数的参数

返回值：成功时返回 0；失败时返回错误编号。



pthread_self(): 用于获取当前线程的ID。这对于需要在线程内部识别自身的情况非常有用

pthread_t pthread_self(void);
这个函数不接受任何参数，并返回调用它的线程的唯一标识符(pthread_t)。在多线程编程中，这个函数可以帮助用户确定哪个线程正在执行特定代码段，或者用于比较不同线程的ID以确认它们是否相同。



pthread_exit(): 终止当前线程

void pthread_exit(void *retval);
retval: 这是一个指向任何类型数据的指针，它可以与其他线程共享计算结果或状态信息。如果不需要返回值，则可以传递 NULL。



pthread_join(): 使调用线程等待指定线程的结束。具体来说，调用 pthread_join() 的线程将被挂起，直到指定的线程结束执行

int pthread_join(pthread_t thread, void **retval);
thread: 想要等待其结束的线程标识符
retval: 指向指针的指针，用于接收线程退出时通过 pthread_exit() 或者线程返回值传递的数据。如果不需要接收退出状态，可以传递 NULL。

成功时返回 0。发生错误返回一个非零错误码。



pthread_cancel(): 请求终止另一个线程。需要注意的是，目标线程是否以及何时响应这个取消请求取决于该线程的取消状态和取消类型设置

int pthread_cancel(pthread_t thread);
thread: 希望取消的目标线程的标识符
成功时返回 0。发生错误返回一个非零错误码。

取消状态与类型:
为了控制如何处理取消请求，每个线程都有两个属性：取消状态(enabled/disabled)和取消类型(deferred/asynchronous)
可以通过以下函数进行查询和设置：

有关取消状态：
	pthread_setcancelstate(): 设置线程的取消状态（启用或禁用）。
	pthread_getcancelstate(): 获取线程当前的取消状态。
有关取消类型：
	pthread_setcanceltype(): 设置取消类型（延迟取消或异步取消）。
	pthread_getcanceltype(): 获取线程当前的取消类型。
	
默认情况下，线程的取消状态是启用的，并且取消类型是延迟取消(deferred cancellation)，
延迟取消意味着线程只会在达到一个取消点时才会检查并响应取消请求。
取消点是一些特定的函数调用位置，在这些位置线程会检查是否有取消请求等待处理。



pthread_testcancel(): 显式设置取消点

除了pthread_testcancel()手动插入取消点外，很多标准库函数也会自动作为取消点，例如：
1.大多数同步原语相关的函数，如 pthread_cond_wait(), pthread_cond_timedwait()
2.I/O 相关的阻塞操作，如 read(), write(), select()
3.休眠函数，如 sleep(), nanosleep()
4.线程池管理相关函数，如 pthread_join(), pthread_barrier_wait()



pthread_detach(): 用于将指定的线程置于分离状态。
当一个线程被分离后，它的资源会在终止时自动释放回系统，而不需要显式地调用pthread_join()来等待其结束和回收资源

int pthread_detach(pthread_t thread);
thread: 要设置为分离状态的线程标识符
成功时返回 0。错误返回一个非零错误码

---------------------------------------------------------------------------------------------------

线程控制原语			进程控制原语
pthread_create()		fork()
pthread_self()			getpid()
pthread_exit()			exit()
pthread_join()			wait(), waitpid()
pthread_cancel()		kill(pid,SIGKILL)
pthread_detach()

---------------------------------------------------------------------------------------------------